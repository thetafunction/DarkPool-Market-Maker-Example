# EIP-712 Signature Guide

This document explains how Market Makers sign quotes using EIP-712.

## Overview

The DarkPool system uses EIP-712 typed data signatures to verify Market Maker quotes. Signed quotes are submitted to the on-chain verifying contract for execution.

## Domain Configuration

Each chain's verifying contract has its own EIP-712 Domain:

```go
type EIP712Domain struct {
    Name              string  // "DarkPool RFQ Manager"
    Version           string  // "1"
    ChainID           uint256 // Chain ID
    VerifyingContract address // Verifying contract address
}
```

**Domain Separator Calculation**:

```solidity
keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256(bytes(name)),
    keccak256(bytes(version)),
    chainId,
    verifyingContract
))
```

## MMQuote Struct

```go
type MMQuote struct {
    RFQManager  address // Verifying contract address
    From        address // User address (transaction initiator)
    To          address // User address (token recipient)
    InputToken  address // Input token address
    OutputToken address // Output token address
    AmountIn    uint256 // Input amount (native decimals)
    AmountOut   uint256 // Output amount (native decimals)
    Deadline    uint256 // Expiration time (Unix seconds)
    Nonce       uint256 // Anti-replay nonce
    ExtraData   bytes   // Optional opaque bytes
}
```

### Field Descriptions

| Field | Description |
|-------|-------------|
| RFQManager | Verifying contract address, same as Domain's verifyingContract |
| From | User address (transaction initiator) |
| To | User address (token recipient), usually same as From |
| InputToken | Token address the user is selling (0x0 for native token) |
| OutputToken | Token address the user is buying |
| AmountIn | Input amount, **uses native decimals** |
| AmountOut | Minimum output amount (after slippage), **uses native decimals** |
| Deadline | Quote expiration time |
| Nonce | Generated by server, prevents replay attacks |
| ExtraData | Optional opaque bytes (demo uses empty bytes) |

### Precision Notes

**Important**: `AmountIn` and `AmountOut` in signatures use the token's **native decimals**, not 18 decimals.

Examples:
- USDC (6 decimals): 1 USDC = 1000000
- WETH (18 decimals): 1 WETH = 1000000000000000000

## ExtraData

`ExtraData` is an optional opaque byte array that can carry custom parameters.
This demo does not set it and uses empty bytes.

## Signing Process

### 1. Build MMQuote

```go
extraData := []byte{} // Optional opaque bytes

mmQuote := &MMQuote{
    RFQManager:  verifyingContract,
    From:        userAddress,
    To:          userAddress,
    InputToken:  tokenIn,
    OutputToken: tokenOut,
    AmountIn:    amountIn,       // native decimals
    AmountOut:   amountOutMin,   // native decimals
    Deadline:    deadline,
    Nonce:       nonce,
    ExtraData:   extraData,
}
```

### 2. Calculate Struct Hash

```go
// TypeHash
typeHash = keccak256("MMQuote(address rfq_manager,address from,address to,address inputToken,address outputToken,uint256 amountIn,uint256 amountOut,uint256 deadline,uint256 nonce,bytes32 extraDataHash)")

// Struct Hash
structHash = keccak256(abi.encode(
    typeHash,
    rfq_manager,
    from,
    to,
    inputToken,
    outputToken,
    amountIn,
    amountOut,
    deadline,
    nonce,
    keccak256(extraData)  // Note: extraData must be hashed first
))
```

### 3. Calculate EIP-712 Digest

```go
digest = keccak256(
    "\x19\x01" ||
    domainSeparator ||
    structHash
)
```

### 4. ECDSA Signing

```go
signature = ecdsaSign(digest, privateKey)

// Adjust v value to 27 or 28
if signature[64] < 27 {
    signature[64] += 27
}
```

## Code Example

See `internal/signer/signer.go` for the complete signing implementation.

```go
// Sign MMQuote
func (s *signer) SignMMQuote(chainID uint64, quote *MMQuote) ([]byte, error) {
    // Get Domain Separator
    domainSeparator, ok := s.domainManager.GetPoolDomainSeparator(chainID)
    if !ok {
        return nil, fmt.Errorf("domain not configured for chainId %d", chainID)
    }

    // Calculate struct hash
    structHash, err := hashMMQuote(quote)
    if err != nil {
        return nil, err
    }

    // Calculate EIP-712 digest
    digest := crypto.Keccak256Hash(
        []byte{0x19, 0x01},
        domainSeparator,
        structHash,
    )

    // ECDSA signing
    sig, err := crypto.Sign(digest.Bytes(), s.privateKey)
    if err != nil {
        return nil, err
    }

    // Adjust v value
    if sig[64] < 27 {
        sig[64] += 27
    }

    return sig, nil
}
```

## Common Issues

### 1. Signature Verification Failed

Check:
- Domain configuration matches the contract
- AmountIn/AmountOut use native decimals
- Token addresses are correct (native token uses 0x0 vs Wrapped)

### 2. Nonce Error

Nonce is provided by the server in QuoteRequest, use it directly.

### 3. Deadline Expired

Ensure Deadline is a future time, typically current time + quote validity period (e.g., 30 seconds).
