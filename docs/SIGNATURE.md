# EIP-712 Signature Guide

This document explains how Market Makers sign quotes using EIP-712.

## Overview

The DarkPool system uses EIP-712 typed data signatures to verify Market Maker quotes. Signed quotes are submitted to the on-chain DarkPool Pool contract for execution.

## Domain Configuration

Each chain's DarkPool Pool contract has its own EIP-712 Domain:

```go
type EIP712Domain struct {
    Name              string  // "DarkPool Pool"
    Version           string  // "1"
    ChainID           uint256 // Chain ID
    VerifyingContract address // DarkPool Pool contract address
}
```

**Domain Separator Calculation**:

```solidity
keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256(bytes(name)),
    keccak256(bytes(version)),
    chainId,
    verifyingContract
))
```

## MMQuote Struct

```go
type MMQuote struct {
    Pool        address // DarkPool Pool contract address
    From        address // User address
    To          address // User address
    InputToken  address // Input token address
    OutputToken address // Output token address
    AmountIn    uint256 // Input amount (native decimals)
    AmountOut   uint256 // Output amount (native decimals)
    Deadline    uint256 // Expiration time (Unix seconds)
    Nonce       uint256 // Anti-replay nonce
    ExtraData   bytes   // Extra data (ABI encoded)
}
```

### Field Descriptions

| Field | Description |
|-------|-------------|
| Pool | DarkPool Pool contract address, same as Domain's verifyingContract |
| From | User address (transaction initiator) |
| To | User address (token recipient), usually same as From |
| InputToken | Token address the user is selling (0x0 for native token) |
| OutputToken | Token address the user is buying |
| AmountIn | Input amount, **uses native decimals** |
| AmountOut | Minimum output amount (after slippage), **uses native decimals** |
| Deadline | Quote expiration time |
| Nonce | Generated by server, prevents replay attacks |
| ExtraData | Additional parameters required for contract execution |

### Precision Notes

**Important**: `AmountIn` and `AmountOut` in signatures use the token's **native decimals**, not 18 decimals.

Examples:
- USDC (6 decimals): 1 USDC = 1000000
- WETH (18 decimals): 1 WETH = 1000000000000000000

## ExtraData Encoding

```go
type ExtraDataParams struct {
    Pool              address // V3 Pool address (for swap)
    ZeroForOne        bool    // Swap direction
    SqrtPriceLimitX96 uint160 // Price limit
    CallbackData      bytes   // Callback data
}

// ABI encoding format
extraData = abi.encode(pool, zeroForOne, sqrtPriceLimitX96, callbackData)
```

### CallbackData

```go
// Callback data only contains payToken address
callbackData = abi.encode(payToken)
```

`payToken` is the token address to transfer from Vault (i.e., InputToken, or its Wrapped version for native tokens).

### ZeroForOne Determination

Uniswap V3's `zeroForOne` indicates swap direction:
- `true`: token0 → token1
- `false`: token1 → token0

Determination method:
```go
zeroForOne = (sellerToken == token0)
```

Where `token0` is the token with the smaller address.

### SqrtPriceLimitX96

Price limit parameter:
- `zeroForOne=true`: Use minimum price limit (MIN_SQRT_RATIO + 1)
- `zeroForOne=false`: Use maximum price limit (MAX_SQRT_RATIO - 1)

```go
const MIN_SQRT_RATIO = 4295128739
const MAX_SQRT_RATIO = "1461446703485210103287273052203988822378723970342"

func MinMaxSqrtPriceX96(zeroForOne bool) *big.Int {
    if zeroForOne {
        return MIN_SQRT_RATIO + 1
    }
    return MAX_SQRT_RATIO - 1
}
```

## Signing Process

### 1. Build MMQuote

```go
mmQuote := &MMQuote{
    Pool:        poolAddress,
    From:        userAddress,
    To:          userAddress,
    InputToken:  tokenIn,
    OutputToken: tokenOut,
    AmountIn:    amountIn,       // native decimals
    AmountOut:   amountOutMin,   // native decimals
    Deadline:    deadline,
    Nonce:       nonce,
    ExtraData:   extraData,
}
```

### 2. Calculate Struct Hash

```go
// TypeHash
typeHash = keccak256("MMQuote(address pool,address from,address to,address inputToken,address outputToken,uint256 amountIn,uint256 amountOut,uint256 deadline,uint256 nonce,bytes32 extraDataHash)")

// Struct Hash
structHash = keccak256(abi.encode(
    typeHash,
    pool,
    from,
    to,
    inputToken,
    outputToken,
    amountIn,
    amountOut,
    deadline,
    nonce,
    keccak256(extraData)  // Note: extraData must be hashed first
))
```

### 3. Calculate EIP-712 Digest

```go
digest = keccak256(
    "\x19\x01" ||
    domainSeparator ||
    structHash
)
```

### 4. ECDSA Signing

```go
signature = ecdsaSign(digest, privateKey)

// Adjust v value to 27 or 28
if signature[64] < 27 {
    signature[64] += 27
}
```

## Code Example

See `internal/signer/signer.go` for the complete signing implementation.

```go
// Sign MMQuote
func (s *signer) SignMMQuote(chainID uint64, quote *MMQuote) ([]byte, error) {
    // Get Domain Separator
    domainSeparator, ok := s.domainManager.GetPoolDomainSeparator(chainID)
    if !ok {
        return nil, fmt.Errorf("domain not configured for chainId %d", chainID)
    }

    // Calculate struct hash
    structHash, err := hashMMQuote(quote)
    if err != nil {
        return nil, err
    }

    // Calculate EIP-712 digest
    digest := crypto.Keccak256Hash(
        []byte{0x19, 0x01},
        domainSeparator,
        structHash,
    )

    // ECDSA signing
    sig, err := crypto.Sign(digest.Bytes(), s.privateKey)
    if err != nil {
        return nil, err
    }

    // Adjust v value
    if sig[64] < 27 {
        sig[64] += 27
    }

    return sig, nil
}
```

## Common Issues

### 1. Signature Verification Failed

Check:
- Domain configuration matches the contract
- AmountIn/AmountOut use native decimals
- Token addresses are correct (native token uses 0x0 vs Wrapped)
- ExtraData encoding is correct

### 2. Nonce Error

Nonce is provided by the server in QuoteRequest, use it directly.

### 3. Deadline Expired

Ensure Deadline is a future time, typically current time + quote validity period (e.g., 30 seconds).
